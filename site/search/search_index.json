{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue dans la prairie Ce site sert a document\u00e9 tout les projets fait au cours de ma formation de DEV IA. Comment mettre \u00e0 jour ma doc ? Pour mettre \u00e0 jour la documentation, il suffit de modifier ou d\u2019ajouter des fichiers Markdown ( .md ) dans le dossier docs . Pour visualiser les modifications en local : python -m mkdocs serve Une fois les changements termin\u00e9s, il faut les publier en ligne : git add . git commit -m \"Mise \u00e0 jour de la documentation\" git push python -m mkdocs gh-deploy Une fois fini la console vous indiquera la lien de la page.","title":"Accueil"},{"location":"#bienvenue-dans-la-prairie","text":"Ce site sert a document\u00e9 tout les projets fait au cours de ma formation de DEV IA.","title":"Bienvenue dans la prairie"},{"location":"#comment-mettre-a-jour-ma-doc","text":"Pour mettre \u00e0 jour la documentation, il suffit de modifier ou d\u2019ajouter des fichiers Markdown ( .md ) dans le dossier docs . Pour visualiser les modifications en local : python -m mkdocs serve Une fois les changements termin\u00e9s, il faut les publier en ligne : git add . git commit -m \"Mise \u00e0 jour de la documentation\" git push python -m mkdocs gh-deploy Une fois fini la console vous indiquera la lien de la page.","title":"Comment mettre \u00e0 jour ma doc ?"},{"location":"asch/","text":"l'exp\u00e9rience de Asch Dans cet exercice on doit entrainer un model \u00e0 partir d'un tableau qui simule l'exp\u00e9rience d'Asch ( Le paradigme d'Asch est une \u00e9tude fondamentale pour comprendre la pression des pairs au sein d'un groupe . Les exp\u00e9riences d'Asch ont d\u00e9montr\u00e9 comment les individus sont influenc\u00e9s par l'opinion majoritaire d'un groupe, m\u00eame lorsque celle-ci est en contradiction avec leur propre jugement. ) le model entrain\u00e9 doit repr\u00e9senter la personne pi\u00e9g\u00e9e qui doit choisir la barre de la m\u00eame taille que la r\u00e9f\u00e9rence. pour cela on cr\u00e9e un tableau de donn\u00e9 qui va contenir la V la victime et A B C D les complices qui vont r\u00e9pondre faux et les barres 1 2 3 et REF. Creation du dataframe Lien vers le code complet #cr\u00e9er une fonction qui remplit dataframe avec 1,2,3 et ref avec 1 ou 2 ou 3 qui est = \u00e0 ref et les autre aleatoire mais tous different,puis A,B,C,D qui vont choisir une barre aleatoirement parmi 1,2,3 qui n'est pas egale a ref def auto(n) : cr\u00e9e 100 lignes de barres qui sont toujours differentes: valeurs_barres = [random.sample(range(0, 101), 3) for _ in range(100)] ici c'est le \"sample\" qui permet qu'il n'y ai pas de doublon ensuite on cr\u00e9e un le tableau avec des colonnes 1,2,3 pour valeurr \"valeurs_barres\" df = pd.DataFrame(valeurs_barres,columns=[\"1\",\"2\",\"3\"],) puis ajouter une colonne ref qui prend une valeur aleatoire parmi 1,2,3: df[\"ref\"] = [random.choice(v) for v in valeurs_barres] On determine les choix de colonnes des complices cols = [\"1\",\"2\",\"3\"] on met dans finalChoices le choix final finalChoices = [] Ensuite on va determiner les choix des complices en fonction des barres # pour chaque ligne dans df for l in range(len(df)): # on prend la valeur de ref pas ref directement ref_val = df.loc[l, \"ref\"] # on determine les choix possibles parmis les colonnes qui ne sont pas egale a ref choix_possibles = [c for c in cols if df.loc[l, c] != ref_val] # on ajoute un choix aleatoire parmi les choix possibles finalChoices.append(random.choice(choix_possibles)) et on attribu un choix final a chaque complice df[\"A\"] = finalChoices df[\"B\"] = finalChoices df[\"C\"] = finalChoices df[\"D\"] = finalChoices df[\"V\"]= np.nan et on garde V vide qui sera remplis par notre focntion solve puis le model.","title":"Asch"},{"location":"asch/#lexperience-de-asch","text":"Dans cet exercice on doit entrainer un model \u00e0 partir d'un tableau qui simule l'exp\u00e9rience d'Asch ( Le paradigme d'Asch est une \u00e9tude fondamentale pour comprendre la pression des pairs au sein d'un groupe . Les exp\u00e9riences d'Asch ont d\u00e9montr\u00e9 comment les individus sont influenc\u00e9s par l'opinion majoritaire d'un groupe, m\u00eame lorsque celle-ci est en contradiction avec leur propre jugement. ) le model entrain\u00e9 doit repr\u00e9senter la personne pi\u00e9g\u00e9e qui doit choisir la barre de la m\u00eame taille que la r\u00e9f\u00e9rence. pour cela on cr\u00e9e un tableau de donn\u00e9 qui va contenir la V la victime et A B C D les complices qui vont r\u00e9pondre faux et les barres 1 2 3 et REF.","title":"l'exp\u00e9rience de Asch"},{"location":"asch/#creation-du-dataframe","text":"Lien vers le code complet #cr\u00e9er une fonction qui remplit dataframe avec 1,2,3 et ref avec 1 ou 2 ou 3 qui est = \u00e0 ref et les autre aleatoire mais tous different,puis A,B,C,D qui vont choisir une barre aleatoirement parmi 1,2,3 qui n'est pas egale a ref def auto(n) : cr\u00e9e 100 lignes de barres qui sont toujours differentes: valeurs_barres = [random.sample(range(0, 101), 3) for _ in range(100)] ici c'est le \"sample\" qui permet qu'il n'y ai pas de doublon ensuite on cr\u00e9e un le tableau avec des colonnes 1,2,3 pour valeurr \"valeurs_barres\" df = pd.DataFrame(valeurs_barres,columns=[\"1\",\"2\",\"3\"],) puis ajouter une colonne ref qui prend une valeur aleatoire parmi 1,2,3: df[\"ref\"] = [random.choice(v) for v in valeurs_barres] On determine les choix de colonnes des complices cols = [\"1\",\"2\",\"3\"] on met dans finalChoices le choix final finalChoices = [] Ensuite on va determiner les choix des complices en fonction des barres # pour chaque ligne dans df for l in range(len(df)): # on prend la valeur de ref pas ref directement ref_val = df.loc[l, \"ref\"] # on determine les choix possibles parmis les colonnes qui ne sont pas egale a ref choix_possibles = [c for c in cols if df.loc[l, c] != ref_val] # on ajoute un choix aleatoire parmi les choix possibles finalChoices.append(random.choice(choix_possibles)) et on attribu un choix final a chaque complice df[\"A\"] = finalChoices df[\"B\"] = finalChoices df[\"C\"] = finalChoices df[\"D\"] = finalChoices df[\"V\"]= np.nan et on garde V vide qui sera remplis par notre focntion solve puis le model.","title":"Creation du dataframe"},{"location":"gamecard/","text":"Card Game Simulation d\u2019un jeu de cartes entre un ROBOT et un HUMAIN, avec comparaison de strat\u00e9gies. Lien vers le depot \u00c9nonc\u00e9 de l\u2019exercice Le but de cet exercice est de simuler un jeu de cartes tr\u00e8s simple entre deux joueurs : - un ROBOT - un HUMAIN Puis : - simuler un grand nombre de parties - calculer le pourcentage de victoire du robot - tester diff\u00e9rentes strat\u00e9gies de jeu pour comparer leurs performances R\u00e8gles du jeu Mat\u00e9riel 10 cartes au total : 5 cartes rond num\u00e9rot\u00e9es de 0 \u00e0 4 5 cartes carr\u00e9 num\u00e9rot\u00e9es de 1 \u00e0 5 Joueurs 2 joueurs : ROBOT et HUMAIN D\u00e9roulement Chaque joueur re\u00e7oit 5 cartes au hasard La partie se joue en 5 tours \u00c0 chaque tour : Le robot joue une carte L\u2019humain joue une carte Le joueur qui a la carte avec la plus grande valeur gagne le pli En cas d\u2019\u00e9galit\u00e9, le robot gagne Le joueur qui gagne au moins 3 plis remporte la partie Structure du projet Le projet est d\u00e9coup\u00e9 en plusieurs fichiers pour s\u00e9parer les responsabilit\u00e9s : Card.py \u2192 repr\u00e9sentation d\u2019une carte Joueur.py \u2192 gestion d\u2019un joueur strategy.py \u2192 strat\u00e9gies de jeu parties.py \u2192 logique d\u2019une partie compl\u00e8te main.py \u2192 simulation de plusieurs parties et statistiques Classe Carte Chaque carte est d\u00e9finie par : - un chiffre - une forme class Carte: def __init__(self, chiffre, forme): self.chiffre = chiffre self.forme = forme def __str__(self): return str(self.chiffre) + str(self.forme) --- Classe Joueur ( Joueur.py ) La classe Player repr\u00e9sente un joueur du jeu. Un joueur poss\u00e8de : - un nom ( name ) - une main de cartes ( hand ) - un nombre de points ( points ) - une strat\u00e9gie qui d\u00e9termine quelle carte jouer Initialisation du joueur from Card import Carte class Player: def __init__(self, name, hand, points=0, strategy=None): self.name = name self.hand = hand self.points = points self.strategy = strategy Strat\u00e9gies de jeu ( strategy.py ) Une strat\u00e9gie est une fonction qui choisit quelle carte jouer. Elle re\u00e7oit : - hand \u2192 la main du joueur (liste de cartes) - carte \u2192 la carte jou\u00e9e par l\u2019adversaire (ou None si on ne sait pas) Elle doit retourner une Carte (et l\u2019enlever de la main). Strat\u00e9gie al\u00e9atoire import random def rand(hand, carte): random.shuffle(hand) return hand.pop() Elle dit au joueur de toujours jouer une carte au pif. Strategie de la plus Grande def plusGrande(hand, carte): hand.sort(key=lambda carte: carte.chiffre) return hand.pop(-1) On range la liste de carte dans l'ordre croissant puis on joue la derniere (donc la plus grande). Strat\u00e9gie de la plus petite def plusPetite(hand, carte): hand.sort(key=lambda carte: carte.chiffre) return hand.pop() Pareil au pr\u00e9c\u00e9dent sauf qu'on joue la 1er carte (donc la plus petite). Strat\u00e9gie smart def smart(hand, carte): if carte: hand.sort(key=lambda c: c.chiffre) for c in hand: if c.chiffre > carte.chiffre: hand.remove(c) return c return plusPetite(hand, carte) Cette fois le joueur va r\u00e9fl\u00e9chir un peu plus on va lui faire comparer la carte jou\u00e9e par l'adversaire pour qu'il joue la plus grande s'il n'a pas la plus grande il joue la plus petite pour ne pas perdre de grosses cartes. D\u00e9roulement de la partie ( parties.py ) Le fichier parties.py contient la fonction partie() qui simule une partie compl\u00e8te entre un ROBOT et un HUMAIN. Cette fonction permet de : - cr\u00e9er la pioche - m\u00e9langer et distribuer les cartes - jouer 5 tours - compter les points - d\u00e9terminer le gagnant D\u00e9finition de la fonction def partie(strategy_humain, strategy_robot): La fonction prend en param\u00e8tre : strategy_humain : strat\u00e9gie utilis\u00e9e par l\u2019humain strategy_robot : strat\u00e9gie utilis\u00e9e par le robot Cela permet de tester diff\u00e9rentes combinaisons de strat\u00e9gies. Cr\u00e9ation de la pioche On commence par cr\u00e9er une liste pioche contenant les 10 cartes du jeu. pioche = [] for chiffre in range(1, 6): pioche.append(Carte(chiffre, \"\u25cb\")) for chiffre in range(0, 5): pioche.append(Carte(chiffre, \"\u25a2\")) puis on la melange random.shuffle(pioche) Cr\u00e9ation des joueurs # Il y a 2 joueurs : le ROBOT et l\u2019HUMAIN. humain = Player(\"HUMAIN\", [], strategy=strategy_humain) robot = Player(\"ROBOT\", [], strategy=strategy_robot) Chaque joueur poss\u00e8de un nom, une main vide au d\u00e9part et une strat\u00e9gie d\u00e9finie lors de l\u2019appel de la fonction. Distribution des cartes Les cartes sont distribu\u00e9es alternativement jusqu\u2019\u00e0 ce que la pioche soit vide. while len(pioche) > 0: humain.hand.append(pioche.pop(-1)) robot.hand.append(pioche.pop(-1)) \u00c0 la fin de la distribution : l\u2019humain poss\u00e8de 5 cartes le robot poss\u00e8de 5 cartes D\u00e9roulement des tours La partie se joue en 5 tours. for tour in range(5): carte_du_robot = robot.play(carte_de_humain) carte_de_humain = humain.play(carte_du_robot) \u00c0 chaque tour : - le robot joue une carte - l\u2019humain joue une carte en r\u00e9ponse les strat\u00e9gies d\u00e9terminent automatiquement les cartes jou\u00e9es. \u00c0 la fin des de chaque plis, le gagnant est d\u00e9termin\u00e9 ainsi : if carte_du_robot.chiffre >= carte_de_humain.chiffre: points_robot += 1 Si le robot gagne le pli, son nombre de points augmente de 1. \u00c0 la fin des 5 tours, le gagnant est d\u00e9termin\u00e9 ainsi : return robot if points_robot >= 3 else humain Le robot gagne s\u2019il remporte au moins 3 plis, sinon c\u2019est l\u2019humain qui gagne la partie. Simulation de plusieurs parties ( main.py ) Le fichier main.py permet de lancer un grand nombre de parties afin de calculer le pourcentage de victoire du robot en fonction des strat\u00e9gies utilis\u00e9es. n_parties = 1000 victoires_robot = 0 n_parties : nombre total de parties simul\u00e9es victoires_robot : compteur du nombre de victoires du robot On lance n_parties simulations cons\u00e9cutives. for i in range(n_parties): gagnant = partie( strategy_humain=smart, strategy_robot=smart ) une nouvelle partie est simul\u00e9e les strat\u00e9gies de l\u2019humain et du robot sont d\u00e9finies ici la fonction partie() retourne le gagnant puis on determine le gagnant if gagnant.name == \"ROBOT\": victoires_robot += 1 puis on affiche le pourcentage de victoire du robot print(\"% victoire robot: \", (victoires_robot / n_parties)*100)","title":"Game card"},{"location":"gamecard/#card-game","text":"Simulation d\u2019un jeu de cartes entre un ROBOT et un HUMAIN, avec comparaison de strat\u00e9gies. Lien vers le depot","title":"Card Game"},{"location":"gamecard/#enonce-de-lexercice","text":"Le but de cet exercice est de simuler un jeu de cartes tr\u00e8s simple entre deux joueurs : - un ROBOT - un HUMAIN Puis : - simuler un grand nombre de parties - calculer le pourcentage de victoire du robot - tester diff\u00e9rentes strat\u00e9gies de jeu pour comparer leurs performances","title":"\u00c9nonc\u00e9 de l\u2019exercice"},{"location":"gamecard/#regles-du-jeu","text":"","title":"R\u00e8gles du jeu"},{"location":"gamecard/#materiel","text":"10 cartes au total : 5 cartes rond num\u00e9rot\u00e9es de 0 \u00e0 4 5 cartes carr\u00e9 num\u00e9rot\u00e9es de 1 \u00e0 5","title":"Mat\u00e9riel"},{"location":"gamecard/#joueurs","text":"2 joueurs : ROBOT et HUMAIN","title":"Joueurs"},{"location":"gamecard/#deroulement","text":"Chaque joueur re\u00e7oit 5 cartes au hasard La partie se joue en 5 tours \u00c0 chaque tour : Le robot joue une carte L\u2019humain joue une carte Le joueur qui a la carte avec la plus grande valeur gagne le pli En cas d\u2019\u00e9galit\u00e9, le robot gagne Le joueur qui gagne au moins 3 plis remporte la partie","title":"D\u00e9roulement"},{"location":"gamecard/#structure-du-projet","text":"Le projet est d\u00e9coup\u00e9 en plusieurs fichiers pour s\u00e9parer les responsabilit\u00e9s : Card.py \u2192 repr\u00e9sentation d\u2019une carte Joueur.py \u2192 gestion d\u2019un joueur strategy.py \u2192 strat\u00e9gies de jeu parties.py \u2192 logique d\u2019une partie compl\u00e8te main.py \u2192 simulation de plusieurs parties et statistiques","title":"Structure du projet"},{"location":"gamecard/#classe-carte","text":"Chaque carte est d\u00e9finie par : - un chiffre - une forme class Carte: def __init__(self, chiffre, forme): self.chiffre = chiffre self.forme = forme def __str__(self): return str(self.chiffre) + str(self.forme) ---","title":"Classe Carte"},{"location":"gamecard/#classe-joueur-joueurpy","text":"La classe Player repr\u00e9sente un joueur du jeu. Un joueur poss\u00e8de : - un nom ( name ) - une main de cartes ( hand ) - un nombre de points ( points ) - une strat\u00e9gie qui d\u00e9termine quelle carte jouer","title":"Classe Joueur (Joueur.py)"},{"location":"gamecard/#initialisation-du-joueur","text":"from Card import Carte class Player: def __init__(self, name, hand, points=0, strategy=None): self.name = name self.hand = hand self.points = points self.strategy = strategy","title":"Initialisation du joueur"},{"location":"gamecard/#strategies-de-jeu-strategypy","text":"Une strat\u00e9gie est une fonction qui choisit quelle carte jouer. Elle re\u00e7oit : - hand \u2192 la main du joueur (liste de cartes) - carte \u2192 la carte jou\u00e9e par l\u2019adversaire (ou None si on ne sait pas) Elle doit retourner une Carte (et l\u2019enlever de la main).","title":"Strat\u00e9gies de jeu (strategy.py)"},{"location":"gamecard/#strategie-aleatoire","text":"import random def rand(hand, carte): random.shuffle(hand) return hand.pop() Elle dit au joueur de toujours jouer une carte au pif.","title":"Strat\u00e9gie al\u00e9atoire"},{"location":"gamecard/#strategie-de-la-plus-grande","text":"def plusGrande(hand, carte): hand.sort(key=lambda carte: carte.chiffre) return hand.pop(-1) On range la liste de carte dans l'ordre croissant puis on joue la derniere (donc la plus grande).","title":"Strategie de la plus Grande"},{"location":"gamecard/#strategie-de-la-plus-petite","text":"def plusPetite(hand, carte): hand.sort(key=lambda carte: carte.chiffre) return hand.pop() Pareil au pr\u00e9c\u00e9dent sauf qu'on joue la 1er carte (donc la plus petite).","title":"Strat\u00e9gie de la plus petite"},{"location":"gamecard/#strategie-smart","text":"def smart(hand, carte): if carte: hand.sort(key=lambda c: c.chiffre) for c in hand: if c.chiffre > carte.chiffre: hand.remove(c) return c return plusPetite(hand, carte) Cette fois le joueur va r\u00e9fl\u00e9chir un peu plus on va lui faire comparer la carte jou\u00e9e par l'adversaire pour qu'il joue la plus grande s'il n'a pas la plus grande il joue la plus petite pour ne pas perdre de grosses cartes.","title":"Strat\u00e9gie smart"},{"location":"gamecard/#deroulement-de-la-partie-partiespy","text":"Le fichier parties.py contient la fonction partie() qui simule une partie compl\u00e8te entre un ROBOT et un HUMAIN. Cette fonction permet de : - cr\u00e9er la pioche - m\u00e9langer et distribuer les cartes - jouer 5 tours - compter les points - d\u00e9terminer le gagnant","title":"D\u00e9roulement de la partie (parties.py)"},{"location":"gamecard/#definition-de-la-fonction","text":"def partie(strategy_humain, strategy_robot): La fonction prend en param\u00e8tre : strategy_humain : strat\u00e9gie utilis\u00e9e par l\u2019humain strategy_robot : strat\u00e9gie utilis\u00e9e par le robot Cela permet de tester diff\u00e9rentes combinaisons de strat\u00e9gies.","title":"D\u00e9finition de la fonction"},{"location":"gamecard/#creation-de-la-pioche","text":"On commence par cr\u00e9er une liste pioche contenant les 10 cartes du jeu. pioche = [] for chiffre in range(1, 6): pioche.append(Carte(chiffre, \"\u25cb\")) for chiffre in range(0, 5): pioche.append(Carte(chiffre, \"\u25a2\")) puis on la melange random.shuffle(pioche)","title":"Cr\u00e9ation de la pioche"},{"location":"gamecard/#creation-des-joueurs","text":"# Il y a 2 joueurs : le ROBOT et l\u2019HUMAIN. humain = Player(\"HUMAIN\", [], strategy=strategy_humain) robot = Player(\"ROBOT\", [], strategy=strategy_robot) Chaque joueur poss\u00e8de un nom, une main vide au d\u00e9part et une strat\u00e9gie d\u00e9finie lors de l\u2019appel de la fonction.","title":"Cr\u00e9ation des joueurs"},{"location":"gamecard/#distribution-des-cartes","text":"Les cartes sont distribu\u00e9es alternativement jusqu\u2019\u00e0 ce que la pioche soit vide. while len(pioche) > 0: humain.hand.append(pioche.pop(-1)) robot.hand.append(pioche.pop(-1)) \u00c0 la fin de la distribution : l\u2019humain poss\u00e8de 5 cartes le robot poss\u00e8de 5 cartes","title":"Distribution des cartes"},{"location":"gamecard/#deroulement-des-tours","text":"La partie se joue en 5 tours. for tour in range(5): carte_du_robot = robot.play(carte_de_humain) carte_de_humain = humain.play(carte_du_robot) \u00c0 chaque tour : - le robot joue une carte - l\u2019humain joue une carte en r\u00e9ponse les strat\u00e9gies d\u00e9terminent automatiquement les cartes jou\u00e9es. \u00c0 la fin des de chaque plis, le gagnant est d\u00e9termin\u00e9 ainsi : if carte_du_robot.chiffre >= carte_de_humain.chiffre: points_robot += 1 Si le robot gagne le pli, son nombre de points augmente de 1. \u00c0 la fin des 5 tours, le gagnant est d\u00e9termin\u00e9 ainsi : return robot if points_robot >= 3 else humain Le robot gagne s\u2019il remporte au moins 3 plis, sinon c\u2019est l\u2019humain qui gagne la partie.","title":"D\u00e9roulement des tours"},{"location":"gamecard/#simulation-de-plusieurs-parties-mainpy","text":"Le fichier main.py permet de lancer un grand nombre de parties afin de calculer le pourcentage de victoire du robot en fonction des strat\u00e9gies utilis\u00e9es. n_parties = 1000 victoires_robot = 0 n_parties : nombre total de parties simul\u00e9es victoires_robot : compteur du nombre de victoires du robot On lance n_parties simulations cons\u00e9cutives. for i in range(n_parties): gagnant = partie( strategy_humain=smart, strategy_robot=smart ) une nouvelle partie est simul\u00e9e les strat\u00e9gies de l\u2019humain et du robot sont d\u00e9finies ici la fonction partie() retourne le gagnant puis on determine le gagnant if gagnant.name == \"ROBOT\": victoires_robot += 1 puis on affiche le pourcentage de victoire du robot print(\"% victoire robot: \", (victoires_robot / n_parties)*100)","title":"Simulation de plusieurs parties (main.py)"},{"location":"makegroupe/","text":"Fonction pour cr\u00e9e des groupes aleatoirement Cette fonction permet de cr\u00e9er des groupes \u00e0 partir d\u2019une liste d\u2019\u00e9l\u00e9ments, en utilisant un param\u00e8tre k qui d\u00e9finit le nombre de personnes par groupe. Les informations sont stock\u00e9es dans un fichier JSON. Vous trouverez la fonction ici D\u00e9taillons ensemble son fonctionnement Le but de cette fonction c'est de cr\u00e9er groupe juste en donnant la liste des personnes ou autres qui composeront le groupe et combien d'\u00e9l\u00e9ment l'on souhaite par groupes.Le fichier json permet de ne pas avoir modifi\u00e9 le code en lui m\u00eame. exemple : {\"eleves\":[\"alex\",\"bob\",\"chloe\",\"david\",\"elie\",\"franc\",\"gwen\",\"helene\",\"igor\",\"jean\"], \"k\": 3 } Ici si je veux des groupes de 2 ou 4 je n'ai qu'a chang\u00e9 la valeur de k et si je veux ajouter ou enlever des personnes je n'ai qu'a effac\u00e9 leur nom ou en ajouter je peux m\u00eame faire des groupes de fruits \u00e7a n'a pas d'importance. resultat quand on lance le code : groupe final: [['bob', 'elie', 'helene'], ['chloe', 'franc', 'igor'], ['david', 'jean', 'gwen', 'alex']] le resultat est aleatoire,le groupe change \u00e0 chaque fois Comment sa marche ? Regardons le code de plus pr\u00e8s: with open(\"Variable.json\") as Variable: data = json.load(Variable) eleves = data[\"eleves\"] k = data[\"k\"] Cette partie du code permet de r\u00e9cup\u00e9rer les \u00e9l\u00e9ments n\u00e9cessaires, mentionn\u00e9s pr\u00e9c\u00e9demment. Gr\u00e2ce \u00e0 cela, il n\u2019est pas n\u00e9cessaire de modifier le code par la suite, car les valeurs peuvent \u00eatre r\u00e9utilis\u00e9es directement. Ensuite, la fonction groupe(eleves, k) est d\u00e9finie. Cette fonction prend deux param\u00e8tres : - eleves , qui correspond \u00e0 la liste des \u00e9l\u00e8ves, - k , qui d\u00e9finit le nombre de personnes par groupe. Ces param\u00e8tres sont d\u00e9finis en amont et transmis \u00e0 la fonction afin qu\u2019elle puisse les utiliser \u00e0 l\u2019int\u00e9rieur de celle-ci pour cr\u00e9er les groupes. Ensuite on melange la liste d'eleves qu'on \u00e0 recup\u00e9r\u00e9 random.shuffle(eleves) qu'on va l'utilis\u00e9 pour cr\u00e9e la liste de groupe qui du coup sera faite \u00e0 partir de la liste melanger et nom celle remplis dans Json. # cree des groupe de taille k a partir de la liste melanger listgroupe =[eleves[i:i+k]for i in range(0,len(eleves),k)] Ici, on cr\u00e9e la liste listegroupe . On part de la liste eleves , qui est d\u00e9j\u00e0 m\u00e9lang\u00e9e, et on la parcourt par groupes de k \u00e9l\u00e9ments(ici 3). \u00c0 chaque \u00e9tape, on prend les k \u00e9l\u00e8ves suivants afin de former un groupe. Ce m\u00e9canisme se r\u00e9p\u00e8te jusqu\u2019\u00e0 ce que toute la liste des \u00e9l\u00e8ves ait \u00e9t\u00e9 trait\u00e9e. Probleme A partir de la un probleme ce pose: Si je fait un print de ma liste de groupe qui est dans l'exemple de 10 personnes print(\"les groupes avant ajustement sont :\",listgroupe) Le resulat: print(\"les groupes avant ajustement sont :\",listgroupe) les groupes avant ajustement sont : [['igor', 'chloe', 'alex'], ['jean', 'gwen', 'elie'], ['helene', 'franc', 'david'], ['bob']] Bob est seul dans son groupe donc on a un groupe de 1 et on est d'accord si on veut faire des groupes c'est qu'on veut qu'il soit au moins 2 par tout seul. Solution On doit ajouter une condition pour que le Bob soit integr\u00e9 un groupe pour pas qu'il se sente mis a part \ud83d\ude1e. Et quand on veut dire python attention si il se passe \"ca\" fait \"cela\" on cr\u00e9e une condition ! # si la liste fait mini 3 groupe et que le dernier groupe a un seul eleve if len(listgroupe)>=3 and len(listgroupe[-1])== 1 : # ajoute le dernier eleve au groupe precedent listgroupe[-2].append(listgroupe[-1][0]) # Supprime le dernier groupe vide listgroupe.pop() return listgroupe Resultat : print(\"groupe final:\",groupe(eleves,3)) groupe final: [['igor', 'chloe', 'alex'], ['jean', 'gwen', 'elie'], ['helene', 'franc', 'david', 'bob']] Et voila Bob a etait ajouter au groupe d'helene & co il est content.","title":"Make Groupe"},{"location":"makegroupe/#fonction-pour-cree-des-groupes-aleatoirement","text":"Cette fonction permet de cr\u00e9er des groupes \u00e0 partir d\u2019une liste d\u2019\u00e9l\u00e9ments, en utilisant un param\u00e8tre k qui d\u00e9finit le nombre de personnes par groupe. Les informations sont stock\u00e9es dans un fichier JSON. Vous trouverez la fonction ici","title":"Fonction pour cr\u00e9e des groupes aleatoirement"},{"location":"makegroupe/#detaillons-ensemble-son-fonctionnement","text":"Le but de cette fonction c'est de cr\u00e9er groupe juste en donnant la liste des personnes ou autres qui composeront le groupe et combien d'\u00e9l\u00e9ment l'on souhaite par groupes.Le fichier json permet de ne pas avoir modifi\u00e9 le code en lui m\u00eame. exemple : {\"eleves\":[\"alex\",\"bob\",\"chloe\",\"david\",\"elie\",\"franc\",\"gwen\",\"helene\",\"igor\",\"jean\"], \"k\": 3 } Ici si je veux des groupes de 2 ou 4 je n'ai qu'a chang\u00e9 la valeur de k et si je veux ajouter ou enlever des personnes je n'ai qu'a effac\u00e9 leur nom ou en ajouter je peux m\u00eame faire des groupes de fruits \u00e7a n'a pas d'importance. resultat quand on lance le code : groupe final: [['bob', 'elie', 'helene'], ['chloe', 'franc', 'igor'], ['david', 'jean', 'gwen', 'alex']] le resultat est aleatoire,le groupe change \u00e0 chaque fois","title":"D\u00e9taillons ensemble son fonctionnement"},{"location":"makegroupe/#comment-sa-marche","text":"Regardons le code de plus pr\u00e8s: with open(\"Variable.json\") as Variable: data = json.load(Variable) eleves = data[\"eleves\"] k = data[\"k\"] Cette partie du code permet de r\u00e9cup\u00e9rer les \u00e9l\u00e9ments n\u00e9cessaires, mentionn\u00e9s pr\u00e9c\u00e9demment. Gr\u00e2ce \u00e0 cela, il n\u2019est pas n\u00e9cessaire de modifier le code par la suite, car les valeurs peuvent \u00eatre r\u00e9utilis\u00e9es directement. Ensuite, la fonction groupe(eleves, k) est d\u00e9finie. Cette fonction prend deux param\u00e8tres : - eleves , qui correspond \u00e0 la liste des \u00e9l\u00e8ves, - k , qui d\u00e9finit le nombre de personnes par groupe. Ces param\u00e8tres sont d\u00e9finis en amont et transmis \u00e0 la fonction afin qu\u2019elle puisse les utiliser \u00e0 l\u2019int\u00e9rieur de celle-ci pour cr\u00e9er les groupes. Ensuite on melange la liste d'eleves qu'on \u00e0 recup\u00e9r\u00e9 random.shuffle(eleves) qu'on va l'utilis\u00e9 pour cr\u00e9e la liste de groupe qui du coup sera faite \u00e0 partir de la liste melanger et nom celle remplis dans Json. # cree des groupe de taille k a partir de la liste melanger listgroupe =[eleves[i:i+k]for i in range(0,len(eleves),k)] Ici, on cr\u00e9e la liste listegroupe . On part de la liste eleves , qui est d\u00e9j\u00e0 m\u00e9lang\u00e9e, et on la parcourt par groupes de k \u00e9l\u00e9ments(ici 3). \u00c0 chaque \u00e9tape, on prend les k \u00e9l\u00e8ves suivants afin de former un groupe. Ce m\u00e9canisme se r\u00e9p\u00e8te jusqu\u2019\u00e0 ce que toute la liste des \u00e9l\u00e8ves ait \u00e9t\u00e9 trait\u00e9e.","title":"Comment sa marche ?"},{"location":"makegroupe/#probleme","text":"A partir de la un probleme ce pose: Si je fait un print de ma liste de groupe qui est dans l'exemple de 10 personnes print(\"les groupes avant ajustement sont :\",listgroupe) Le resulat: print(\"les groupes avant ajustement sont :\",listgroupe) les groupes avant ajustement sont : [['igor', 'chloe', 'alex'], ['jean', 'gwen', 'elie'], ['helene', 'franc', 'david'], ['bob']] Bob est seul dans son groupe donc on a un groupe de 1 et on est d'accord si on veut faire des groupes c'est qu'on veut qu'il soit au moins 2 par tout seul.","title":"Probleme"},{"location":"makegroupe/#solution","text":"On doit ajouter une condition pour que le Bob soit integr\u00e9 un groupe pour pas qu'il se sente mis a part \ud83d\ude1e. Et quand on veut dire python attention si il se passe \"ca\" fait \"cela\" on cr\u00e9e une condition ! # si la liste fait mini 3 groupe et que le dernier groupe a un seul eleve if len(listgroupe)>=3 and len(listgroupe[-1])== 1 : # ajoute le dernier eleve au groupe precedent listgroupe[-2].append(listgroupe[-1][0]) # Supprime le dernier groupe vide listgroupe.pop() return listgroupe Resultat : print(\"groupe final:\",groupe(eleves,3)) groupe final: [['igor', 'chloe', 'alex'], ['jean', 'gwen', 'elie'], ['helene', 'franc', 'david', 'bob']] Et voila Bob a etait ajouter au groupe d'helene & co il est content.","title":"Solution"},{"location":"react/","text":"La programation r\u00e9active. La r\u00e9activit\u00e9, c\u2019est la capacit\u00e9 d\u2019un syst\u00e8me (site, application, interface) \u00e0 r\u00e9agir automatiquement et imm\u00e9diatement \u00e0 un changement, sans action suppl\u00e9mentaire de l\u2019utilisateur. Ce changement peut venir : -de l\u2019utilisateur (clic, saisie clavier, scroll\u2026) -du syst\u00e8me (donn\u00e9es re\u00e7ues, timer, API, \u00e9tat interne) -du r\u00e9seau (r\u00e9ponse serveur, erreur, chargement termin\u00e9) Point cl\u00e9 : L\u2019interface se met \u00e0 jour parce que l\u2019\u00e9tat change, pas parce qu\u2019on lui dit explicitement de se rafra\u00eechir. exemple : quand vous faites une recherche google les propositions s'actualisent en temps r\u00e9el lorsque vous rentrez du texte. Reactive \u2260 Rapide Il ne faut pas confondre un syst\u00e8me rapide avec un syst\u00e8me r\u00e9active ce n'est pas la m\u00eame chose. Un programme, une interface peut \u00eatre rapide sans pour autant \u00eatre r\u00e9active, un petit exemple pour bien saisir la diff\u00e9rence : On peut courir vite et ne pas etre reactive ici le bonhomme court mais marque une pause avant de saut\u00e9 car il n'a pas anticip\u00e9 l'obstacle donc il s'arrete pour reflechir \u00e0 comment reagir a cette nouvelle information puis il saute. Maintenant on peut voir que le bonhomme court sans interruptions et r\u00e9agies imm\u00e9diatement face au rocher sans avoir besoin de s'arr\u00eater pour r\u00e9fl\u00e9chir . c'est la diff\u00e9rence entre rapide et r\u00e9active, \u00eatre rapide ne signifie pas savoir faire face au probl\u00e8me rencontr\u00e9 et y r\u00e9agir en cons\u00e9quence de mani\u00e8re imm\u00e9diate. Pour une application,un jeu ou autre ne pas \u00eatre r\u00e9active c'est ne pas r\u00e9agir en temps r\u00e9el aux actions de l'utilisateur ou l'arriv\u00e9e d'une nouvelle donn\u00e9e.Si votre programme a besoin de s'actualiser en permanence d\u00e8s qu'il re\u00e7oit une nouvelle information il n'est pas r\u00e9actif m\u00eame s'il le fait rapidement.","title":"Programation r\u00e9active"},{"location":"react/#la-programation-reactive","text":"La r\u00e9activit\u00e9, c\u2019est la capacit\u00e9 d\u2019un syst\u00e8me (site, application, interface) \u00e0 r\u00e9agir automatiquement et imm\u00e9diatement \u00e0 un changement, sans action suppl\u00e9mentaire de l\u2019utilisateur. Ce changement peut venir : -de l\u2019utilisateur (clic, saisie clavier, scroll\u2026) -du syst\u00e8me (donn\u00e9es re\u00e7ues, timer, API, \u00e9tat interne) -du r\u00e9seau (r\u00e9ponse serveur, erreur, chargement termin\u00e9) Point cl\u00e9 : L\u2019interface se met \u00e0 jour parce que l\u2019\u00e9tat change, pas parce qu\u2019on lui dit explicitement de se rafra\u00eechir. exemple : quand vous faites une recherche google les propositions s'actualisent en temps r\u00e9el lorsque vous rentrez du texte.","title":"La programation r\u00e9active."},{"location":"react/#reactive-rapide","text":"Il ne faut pas confondre un syst\u00e8me rapide avec un syst\u00e8me r\u00e9active ce n'est pas la m\u00eame chose. Un programme, une interface peut \u00eatre rapide sans pour autant \u00eatre r\u00e9active, un petit exemple pour bien saisir la diff\u00e9rence : On peut courir vite et ne pas etre reactive ici le bonhomme court mais marque une pause avant de saut\u00e9 car il n'a pas anticip\u00e9 l'obstacle donc il s'arrete pour reflechir \u00e0 comment reagir a cette nouvelle information puis il saute. Maintenant on peut voir que le bonhomme court sans interruptions et r\u00e9agies imm\u00e9diatement face au rocher sans avoir besoin de s'arr\u00eater pour r\u00e9fl\u00e9chir . c'est la diff\u00e9rence entre rapide et r\u00e9active, \u00eatre rapide ne signifie pas savoir faire face au probl\u00e8me rencontr\u00e9 et y r\u00e9agir en cons\u00e9quence de mani\u00e8re imm\u00e9diate. Pour une application,un jeu ou autre ne pas \u00eatre r\u00e9active c'est ne pas r\u00e9agir en temps r\u00e9el aux actions de l'utilisateur ou l'arriv\u00e9e d'une nouvelle donn\u00e9e.Si votre programme a besoin de s'actualiser en permanence d\u00e8s qu'il re\u00e7oit une nouvelle information il n'est pas r\u00e9actif m\u00eame s'il le fait rapidement.","title":"Reactive \u2260 Rapide"},{"location":"requetesHTTP/","text":"Comprendre une requ\u00eate HTTP Internet est largement utilis\u00e9 pour permettre aux machines de communiquer entre elles. Voici un exemple de requ\u00eate HTTP : GET https://dummyjson.com:443/recipes?limit=10 HTTP/2 L\u2019objectif est d\u2019analyser la nature, le type et le format des \u00e9l\u00e9ments de cette requ\u00eate. Qu'est-ce qu\u2019une requ\u00eate HTTP ? Une requ\u00eate HTTP est un message envoy\u00e9 par un client \u00e0 un serveur afin de demander une action pr\u00e9cise, comme r\u00e9cup\u00e9rer des donn\u00e9es, envoyer des informations ou modifier une ressource. Qu'est-ce qu\u2019un DNS ? Le DNS (Domain Name System) est un syst\u00e8me qui permet de traduire un nom de domaine lisible par l\u2019humain (ex : dummyjson.com) en adresse IP compr\u00e9hensible par les machines. Qu'est-ce que GET ? GET est une m\u00e9thode HTTP. Elle sert \u00e0 demander des donn\u00e9es au serveur sans modifier l\u2019\u00e9tat des ressources. mais c'est quoi une methode http ? \ud83d\udc49 Une m\u00e9thode HTTP indique l\u2019action que le client demande au serveur . Par exemple : GET : demander des informations POST : envoyer des informations UDAPTE : mettre \u00e0 jours des informations DELETE : supprimer des informations Il en existe plusieurs, mais pour faire court, cela veut dire : \u00ab je veux faire \u00e7a \u00bb. Qu'est-ce que HTTPS ? HTTPS est la version s\u00e9curis\u00e9e du protocole HTTP. Les \u00e9changes entre le client et le serveur sont chiffr\u00e9s, ce qui garantit la confidentialit\u00e9 et l\u2019int\u00e9grit\u00e9 des donn\u00e9es \u00e9chang\u00e9es. Version courte : HTTPS, c\u2019est comme dire : \u201ccoucou, confirme-moi que c\u2019est bien toi, et parlons en priv\u00e9\u201d. Qu'est-ce que dummyjson.com ? dummyjson.com est le nom de domaine du serveur cibl\u00e9 par la requ\u00eate,tout simplement. Qu'est-ce que le port 443 ? Le port 443 est le port standard utilis\u00e9 pour les communications HTTPS. Il indique au serveur sur quel canal r\u00e9seau la communication doit avoir lieu. version courte : Tu frappes \u00e0 la porte 443 parce que c\u2019est la porte d\u2019entr\u00e9e du HTTPS. Qu'est-ce que recipes ? Recipes , c\u2019est ce que l\u2019on veut \u201c GET \u201d sur le serveur.C'est ce qu'on demande . Qu'est-ce que \"?\" ? Le caract\u00e8re ? indique que l\u2019on va ajouter des pr\u00e9cisions \u00e0 la demande. c\u2019est comme dire : \u201c je veux \u00e7a, mais avec ces d\u00e9tails \u201d. Qu\u2019est-ce que limit ? limit est un param\u00e8tre de requ\u00eate. Il permet d\u2019indiquer une contrainte sur la r\u00e9ponse attendue, par exemple le nombre maximum d\u2019\u00e9l\u00e9ments. Qu\u2019est-ce que 10 ? 10 est la valeur associ\u00e9e au param\u00e8tre limit . Cela signifie que la requ\u00eate demande un maximum de 10 \u00e9l\u00e9ments dans la r\u00e9ponse. Qu\u2019est-ce que HTTP/2 ? HTTP/2 est la version du protocole HTTP utilis\u00e9e pour la communication En conclusion \u00c0 quoi \u00e7a sert ? Pas forc\u00e9ment \u00e0 grand-chose au quotidien. Mais savoir ce que l\u2019on tape aide \u00e0 comprendre ce que l\u2019on fait, \u00e0 \u00e9viter les erreurs et \u00e0 ne pas agir \u201cau hasard\u201d.","title":"Requ\u00eates HTTP"},{"location":"requetesHTTP/#comprendre-une-requete-http","text":"Internet est largement utilis\u00e9 pour permettre aux machines de communiquer entre elles. Voici un exemple de requ\u00eate HTTP : GET https://dummyjson.com:443/recipes?limit=10 HTTP/2 L\u2019objectif est d\u2019analyser la nature, le type et le format des \u00e9l\u00e9ments de cette requ\u00eate.","title":"Comprendre une requ\u00eate HTTP"},{"location":"requetesHTTP/#quest-ce-quune-requete-http","text":"Une requ\u00eate HTTP est un message envoy\u00e9 par un client \u00e0 un serveur afin de demander une action pr\u00e9cise, comme r\u00e9cup\u00e9rer des donn\u00e9es, envoyer des informations ou modifier une ressource.","title":"Qu'est-ce qu\u2019une requ\u00eate HTTP ?"},{"location":"requetesHTTP/#quest-ce-quun-dns","text":"Le DNS (Domain Name System) est un syst\u00e8me qui permet de traduire un nom de domaine lisible par l\u2019humain (ex : dummyjson.com) en adresse IP compr\u00e9hensible par les machines.","title":"Qu'est-ce qu\u2019un DNS ?"},{"location":"requetesHTTP/#quest-ce-que-get","text":"GET est une m\u00e9thode HTTP. Elle sert \u00e0 demander des donn\u00e9es au serveur sans modifier l\u2019\u00e9tat des ressources.","title":"Qu'est-ce que GET ?"},{"location":"requetesHTTP/#mais-cest-quoi-une-methode-http","text":"\ud83d\udc49 Une m\u00e9thode HTTP indique l\u2019action que le client demande au serveur . Par exemple : GET : demander des informations POST : envoyer des informations UDAPTE : mettre \u00e0 jours des informations DELETE : supprimer des informations Il en existe plusieurs, mais pour faire court, cela veut dire : \u00ab je veux faire \u00e7a \u00bb.","title":"mais c'est quoi une methode http ?"},{"location":"requetesHTTP/#quest-ce-que-https","text":"HTTPS est la version s\u00e9curis\u00e9e du protocole HTTP. Les \u00e9changes entre le client et le serveur sont chiffr\u00e9s, ce qui garantit la confidentialit\u00e9 et l\u2019int\u00e9grit\u00e9 des donn\u00e9es \u00e9chang\u00e9es. Version courte : HTTPS, c\u2019est comme dire : \u201ccoucou, confirme-moi que c\u2019est bien toi, et parlons en priv\u00e9\u201d.","title":"Qu'est-ce que HTTPS ?"},{"location":"requetesHTTP/#quest-ce-que-dummyjsoncom","text":"dummyjson.com est le nom de domaine du serveur cibl\u00e9 par la requ\u00eate,tout simplement.","title":"Qu'est-ce que dummyjson.com ?"},{"location":"requetesHTTP/#quest-ce-que-le-port-443","text":"Le port 443 est le port standard utilis\u00e9 pour les communications HTTPS. Il indique au serveur sur quel canal r\u00e9seau la communication doit avoir lieu. version courte : Tu frappes \u00e0 la porte 443 parce que c\u2019est la porte d\u2019entr\u00e9e du HTTPS.","title":"Qu'est-ce que le port 443 ?"},{"location":"requetesHTTP/#quest-ce-que-recipes","text":"Recipes , c\u2019est ce que l\u2019on veut \u201c GET \u201d sur le serveur.C'est ce qu'on demande .","title":"Qu'est-ce que recipes ?"},{"location":"requetesHTTP/#quest-ce-que","text":"Le caract\u00e8re ? indique que l\u2019on va ajouter des pr\u00e9cisions \u00e0 la demande. c\u2019est comme dire : \u201c je veux \u00e7a, mais avec ces d\u00e9tails \u201d.","title":"Qu'est-ce que \"?\" ?"},{"location":"requetesHTTP/#quest-ce-que-limit","text":"limit est un param\u00e8tre de requ\u00eate. Il permet d\u2019indiquer une contrainte sur la r\u00e9ponse attendue, par exemple le nombre maximum d\u2019\u00e9l\u00e9ments.","title":"Qu\u2019est-ce que limit ?"},{"location":"requetesHTTP/#quest-ce-que-10","text":"10 est la valeur associ\u00e9e au param\u00e8tre limit . Cela signifie que la requ\u00eate demande un maximum de 10 \u00e9l\u00e9ments dans la r\u00e9ponse.","title":"Qu\u2019est-ce que 10 ?"},{"location":"requetesHTTP/#quest-ce-que-http2","text":"HTTP/2 est la version du protocole HTTP utilis\u00e9e pour la communication","title":"Qu\u2019est-ce que HTTP/2 ?"},{"location":"requetesHTTP/#en-conclusion","text":"\u00c0 quoi \u00e7a sert ? Pas forc\u00e9ment \u00e0 grand-chose au quotidien. Mais savoir ce que l\u2019on tape aide \u00e0 comprendre ce que l\u2019on fait, \u00e0 \u00e9viter les erreurs et \u00e0 ne pas agir \u201cau hasard\u201d.","title":"En conclusion"},{"location":"verification/","text":"Verification Verifie si python et Node sont install\u00e9s et si 2+2 font 4 (on ne sait jamais ca peut changer) Vous trouverez la fonction ici","title":"V\u00e9rification"},{"location":"verification/#verification","text":"Verifie si python et Node sont install\u00e9s et si 2+2 font 4 (on ne sait jamais ca peut changer) Vous trouverez la fonction ici","title":"Verification"}]}